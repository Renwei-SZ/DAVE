# -*- coding: utf-8 -*-
#/*
# * Copyright (c) 2022 Renwei
# *
# * This is a free software; you can redistribute it and/or modify
# * it under the terms of the MIT license. See LICENSE for details.
# */
import re


_copyright_message_for_c_and_go = "\
/*\n\
 * Copyright (c) 2022 Renwei\n\
 *\n\
 * This is a free software; you can redistribute it and/or modify\n\
 * it under the terms of the MIT license. See LICENSE for details.\n\
 *\n\
 * ############################# IMPORTANT INFORMATION ############################\n\
 * The code of this file is automatically generated by tools(Tools/rpc),\n\
 * please do not modify it manually!\n\
 * ############################# IMPORTANT INFORMATION ############################\n\
 * ================================================================================\n\
 */\n\n"\


def _get_struct_body_data(body):
    data_types = ""
    data_name = ""
    data_dimension = ""

    body_index = 0
    while body_index < len(body):
        if body[body_index] != ' ':
            break
        body_index += 1
    while body_index < len(body):
        if body[body_index] == ' ' or body[body_index] == '*':
            break
        body_index += 1
    while body_index < len(body):
        if body[body_index] == ' ' or body[body_index] == '*':
            body_index += 1
        else:
            data_types = body[:body_index]
            break

    body = body[body_index:]
    body_index = 0
    while body_index < len(body):
        if body[body_index] == ' ' or body[body_index] == '[' or (body_index + 1) == len(body):
            if (body_index + 1) == len(body):
                data_name = body[:body_index+1]
                body_index += 1
            else:
                data_name = body[:body_index]
            break
        body_index += 1

    body = body[body_index:]
    body_index = 0
    while body_index < len(body):
        if body[body_index] == '[':
            data_dimension = body[:len(body)]
            break
        body_index += 1

    if data_types != None:
        data_types = data_types.replace(" ", "")
    if data_name != None:
        data_name = data_name.replace(" ", "")
    if data_dimension != None:
        data_dimension = data_dimension.replace(" ", "").replace("][", "*").replace("[", "").replace("]", "")

    return data_name, data_types, data_dimension


def _struct_data_to_dict(data_name, data_types, data_dimension, struct_line):
    if (data_types != "") and (not re.search('[A-Z,a-z,0-9,"_"]+?', data_types)):
        print(f"data_name:{data_name} / {data_types} / {struct_line}")
    if data_types == "struct":
        print(f"data_name:{data_name} / {data_types} / {struct_line}")

    base_data = {}

    types_len = len(data_types)
    if data_types[types_len-1] == '*':
        data_types = data_types[0:types_len-1]+'_ptr'

    base_data["n"] = data_name
    base_data["t"] = data_types
 
    if data_dimension != "":
        base_data["d"] = data_dimension
    return base_data


#
# 目前还不支持结构体内，直接定义嵌套结构体，
# 这个函数主要检测是否有这种定义发生，
# 如果有，就告警！！！
#
def _check_struct_data_has_invalid_define(struct_data):
    if struct_data.count('{') > 1:
        print(f"find unsupport define:{struct_data}")
    return


def _check_struct_list_has_invalid_define(struct_list):
    if struct_list != None:
        for struct_data in struct_list:
            _check_struct_data_has_invalid_define(struct_data)
    return


def _get_struct_name_and_body(struct_data):
    struct_name = re.findall("}(.*?);", struct_data)
    if len(struct_name) == 0:
        struct_name = re.findall("typedef struct(.*?){", struct_data)
    if len(struct_name) == 0:
        struct_name = re.findall("typedef union(.*?){", struct_data)
    struct_body = re.findall("typedef struct.*?\{(.*?)\}.*?;", struct_data)
    if len(struct_body) == 0:
        struct_body = re.findall("typedef union.*?\{(.*?)\}.*?;", struct_data)
    if struct_name == None or struct_name == "" or struct_body == None or struct_body == "":
        print(f"struct_name:{struct_name} struct_body:{struct_body} struct_data:{struct_data}")
    if len(struct_body) == 0:
        print(f"the struct_body is empty:{struct_data} struct_name:{struct_name}")
    return get_array_data(struct_name, 0).replace(" ", ""), struct_body


# =====================================================================


def remove_invalid_data(file_data):
    #
    # 需要按步骤去除
    #
    file_data = re.sub("//.*?\n", " ", file_data)
    file_data = re.sub("\n|\r\n|\t", " ", file_data)
    return file_data


def remove_annotation_data(file_data):
    file_data = re.sub("/\*.*?\*/", "", file_data)
    return remove_invalid_data(file_data)


def get_array_data(array_list, index):
    counter = 0
    ret_array_data = None
    for array_data in array_list:
        if counter >= index:
            ret_array_data = array_data
            break
    return ret_array_data


def get_struct_data(struct_data):
    struct_data = remove_annotation_data(struct_data)
    _check_struct_data_has_invalid_define(struct_data)
    struct_name, struct_body = _get_struct_name_and_body(struct_data)

    base_array = []
    for struct_line in struct_body:
        body_list = re.findall("(.*?);", struct_line)

        for body in body_list:
            data_name, data_types, data_dimension = _get_struct_body_data(body)
            base_dict = _struct_data_to_dict(data_name, data_types, data_dimension, struct_line)
            base_array.append(base_dict)
    return struct_name, base_array


def get_struct_list(file_data):
    file_data = remove_annotation_data(file_data)
    struct_list = re.findall("typedef struct.*?\{.*?\}.*?;", file_data)
    _check_struct_list_has_invalid_define(struct_list)
    return struct_list


def get_enum_id_table(enum_content):
    enum_content = str(re.findall("typedef enum.*?\{(.*?)\}.*?;", enum_content))
    enum_content = enum_content.replace(' ', '').replace('[', '').replace(']', '').replace('\'', '') + ','
    enum_content = str(re.findall('([A-Z,a-z,0-9,_]*)=.*?,|([A-Z,a-z,0-9,_]*),', enum_content))
    enum_content = enum_content.replace('[', '').replace(']', '').replace('(', '').replace(')', '').replace('\'', '').replace(', ,', ',').replace(' ', '')
    enum_content = re.findall("(.*?),", enum_content)
    return enum_content


def copyright_message(file_id, copy_flag='c'):
    if copy_flag == 'c':
        file_id.write(_copyright_message_for_c_and_go)


def include_message(file_id, head_list):
    head_list.sort()
    head_list2 = []
    for include_file in head_list:
        if include_file in head_list2:
            continue
        head_list2.append(include_file)
        include_file = include_file.rsplit("/", 1)[-1]
        file_id.write("#include \"" + include_file + "\"\n")
    file_id.write("\n")


def struct_on_the_table(struct_type, struct_table=None, union_table=None):
    no_ptr_struct_type = struct_type.replace("_ptr", "")
    if no_ptr_struct_type == struct_type:
        has_ptr = False
    else:
        has_ptr = True
    is_struct = True
    if struct_table != None:
        if struct_table.get(struct_type, None) != None:
            return is_struct, has_ptr, struct_type
        if struct_table.get(no_ptr_struct_type, None) != None:
            return is_struct, has_ptr, no_ptr_struct_type
    if union_table != None:
        if union_table.get(struct_type, None) != None:
            return is_struct, has_ptr, struct_type
        if union_table.get(no_ptr_struct_type, None) != None:
            return is_struct, has_ptr, no_ptr_struct_type
    is_struct = False
    return is_struct, has_ptr, struct_type


def struct_dimension_decomposition(struct_dimension):
    high_struct_dimension = struct_dimension.split('*', 1)[0]
    low_struct_dimension = struct_dimension.split('*', 1)[-1]
    if high_struct_dimension == low_struct_dimension:
        return str(1), low_struct_dimension
    else:
        return high_struct_dimension, low_struct_dimension